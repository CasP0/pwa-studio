import { readFile } from "fs/promises";
import fetch from "node-fetch";
import { Headers } from "node-fetch";
import { MsixInfo } from "../interfaces";

import * as vscode from "vscode";

export async function packageForWindows(options: any) {
  const response = await fetch(
    "https://pwabuilder-win-chromium-platform.centralus.cloudapp.azure.com/msix/generatezip",
    {
      method: "POST",
      body: JSON.stringify(options),
      headers: new Headers({ "content-type": "application/json" }),
    }
  );

  return response;
}

export function getSimpleMsixFromArray(...args: string[]): MsixInfo {
  // This creates an unsigned package. Should be considered the bare minimum.
  return {
    url: args[0],
    name: args[1],
    packageId: "com.example.pwa",
    version: "1.0.1",
    allowSigning: true,
    classicPackage: {
      generate: true,
      version: "1.0.0",
    },
  };
}

export function getPublisherMsixFromArray(...args: string[]): MsixInfo {
  return {
    url: args[0],
    name: args[1],
    packageId: args[2],
    version: args[3] || "1.0.1",
    allowSigning: true,
    classicPackage: {
      generate: true,
      version: args[4],
    },
    publisher: {
      displayName: args[5],
      commonName: args[6],
    },
  };
}

export async function buildAndroidPackage(options: any) {
  const generateAppUrl = `https://pwabuilder-cloudapk.azurewebsites.net/generateAppPackage`;
  const response = await fetch(generateAppUrl, {
    method: "POST",
    body: JSON.stringify(options),
    headers: new Headers({ "content-type": "application/json" }),
  });

  console.log(response.status, response.body);

  return response;
}

export async function buildAndroidOptions() {
  const appUrl = await vscode.window.showInputBox({
    prompt: "Enter the URL to your app",
  });

  if (!appUrl) {
    await vscode.window.showErrorMessage("Please enter a URL");
    return;
  }

  const manifestUrl = await vscode.window.showInputBox({
    prompt: "Enter the URL to your manifest",
  });


  if (manifestUrl) {
    // fetch manifest from manifestUrl using node-fetch
    const manifestData = await (await fetch(manifestUrl)).json();
    console.log('manifestData', manifestData);
    const manifest = manifestData;

    return {
      appVersion: "1.0.0.0",
      appVersionCode: 1,
      backgroundColor:
        manifest.background_color || manifest.theme_color || "#FFFFFF",
      display: manifest.display,
      enableNotifications: true,
      enableSiteSettingsShortcut: true,
      fallbackType: "customtabs",
      features: {
        locationDelegation: {
          enabled: true,
        },
        playBilling: {
          enabled: false,
        },
      },
      host: appUrl,
      iconUrl: "https://webboard.app/icons/android/android-launchericon-512-512.png",
      includeSourceCode: false,
      isChromeOSOnly: false,
      launcherName: manifest.short_name.substring(0, 30), // launcher name should be the short name. If none is available, fallback to the full app name.
      name: manifest.name,
      navigationColor: manifest.background_color || manifest.theme_color,
      navigationColorDark: manifest.background_color || manifest.theme_color,
      navigationDividerColor: manifest.background_color || manifest.theme_color,
      navigationDividerColorDark:
        manifest.background_color || manifest.theme_color,
      orientation: manifest.orientation || "default",
      packageId: "com.android.test",
      shortcuts: manifest.shortcuts || [],
      signing: {
        file: null,
        alias: "my-key-alias",
        fullName: `${manifest.short_name || manifest.name || "App"} Admin`,
        organization: manifest.name || "PWABuilder",
        organizationalUnit: "Engineering",
        countryCode: "US",
        keyPassword: "", // If empty, one will be generated by CloudAPK service
        storePassword: "", // If empty, one will be generated by CloudAPK service
      },
      signingMode: "new",
      splashScreenFadeOutDuration: 300,
      startUrl: manifest.start_url,
      themeColor: manifest.theme_color || "#FFFFFF",
      shareTarget: manifest.share_target || [],
      webManifestUrl: manifestUrl,
    };
  }
}
